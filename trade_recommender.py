# -*- coding: utf-8 -*-
"""Trade recommender.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oowxLPczOdGu2MLX_IR57MPxdMKTUer5
"""

pip install yfinance

import requests

def send_telegram_message(message):
    bot_token = '7719067949:AAGDZt5QUJHrfOGJt4frEea0VN08-V00gKA'
  # Replace with your bot token
    chat_id = '1111276484'
      # Replace with your chat ID

    url = f'https://api.telegram.org/bot{bot_token}/sendMessage'
    data = {'chat_id': chat_id, 'text': message}

    response = requests.post(url, data=data)

    if response.status_code == 200:
        print('üì© Telegram alert sent successfully.')
    else:
        print('‚ùå Failed to send Telegram alert.')

import yfinance as yf
import pandas as pd

# Define the tickers
tickers = ['EURUSD=X', 'GC=F', 'CL=F', 'TSLA', 'AAPL']

# Function to fetch live data
def fetch_live_data(ticker):
    data = yf.download(ticker, interval='1m', period='1d')
    return data

# Loop over all tickers and fetch data
for ticker in tickers:
    df = fetch_live_data(ticker)
    print(f"\n{ticker} Live Data:\n", df.tail())

import sqlite3

# Step 1: Connect to SQLite (it will create the DB file if it doesn't exist)
conn = sqlite3.connect('trade_recommendation.db')  # This will create the DB file in your current directory
cursor = conn.cursor()

# Step 2: Create the table
cursor.execute('''
    CREATE TABLE IF NOT EXISTS live_stock_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        ticker TEXT,
        datetime TEXT,
        open_price REAL,
        high_price REAL,
        low_price REAL,
        close_price REAL,
        volume REAL
    )
''')

conn.commit()
print("‚úÖ SQLite database and table created successfully.")

# Step 3: Close the connection for now
cursor.close()
conn.close()

import yfinance as yf
import sqlite3
from datetime import datetime

# Step 1: Connect to SQLite
conn = sqlite3.connect('trade_recommendation.db')
cursor = conn.cursor()

# Step 2: Define the tickers
tickers = ['EURUSD=X', 'GC=F', 'CL=F', 'TSLA', 'AAPL']

# Step 3: Fetch and Insert Data
for ticker in tickers:
    df = yf.download(ticker, interval='1m', period='1d')

    for index, row in df.iterrows():
        sql = '''
            INSERT INTO live_stock_data (ticker, datetime, open_price, high_price, low_price, close_price, volume)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        '''
        values = (
            ticker,
            index.strftime('%Y-%m-%d %H:%M:%S'),
            float(row['Open']),
            float(row['High']),
            float(row['Low']),
            float(row['Close']),
            float(row['Volume'])
        )
        cursor.execute(sql, values)

    conn.commit()
    print(f"‚úÖ Inserted data for {ticker}")

# Step 4: Close connection
cursor.close()
conn.close()
print("‚úÖ All data inserted successfully.")

!pip install pandas_ta

!pip install ta

import pandas as pd
import sqlite3
from ta.momentum import RSIIndicator
from ta.trend import SMAIndicator

# Step 1: Connect to SQLite
conn = sqlite3.connect('trade_recommendation.db')

# Step 2: Load the data into a DataFrame
query = "SELECT * FROM live_stock_data"
df = pd.read_sql(query, conn)

# Step 3: Close the database connection
conn.close()

# Step 4: Process data for each stock separately
tickers = df['ticker'].unique()
indicator_data = {}

for ticker in tickers:
    stock_df = df[df['ticker'] == ticker].copy()
    stock_df['datetime'] = pd.to_datetime(stock_df['datetime'])
    stock_df = stock_df.sort_values('datetime')

    # Calculate RSI
    rsi = RSIIndicator(close=stock_df['close_price'], window=14)
    stock_df['RSI'] = rsi.rsi()

    # Calculate 20-period Moving Average
    ma20 = SMAIndicator(close=stock_df['close_price'], window=20)
    stock_df['MA20'] = ma20.sma_indicator()

    # Calculate 50-period Moving Average
    ma50 = SMAIndicator(close=stock_df['close_price'], window=50)
    stock_df['MA50'] = ma50.sma_indicator()

    # Save to dictionary for later use
    indicator_data[ticker] = stock_df

    print(f"‚úÖ Calculated indicators for {ticker}")

print("‚úÖ All technical indicators calculated successfully.")

import numpy as np

# We will use the first stock for now, you can loop over others later
selected_stock = 'TSLA'
df_model = indicator_data[selected_stock].copy()

# Step 1: Drop rows with NaN values caused by indicator calculations
df_model.dropna(inplace=True)

# Step 2: Create the target variable
# If next close price > current close price ‚Üí label as 1 (buy), else 0 (don't buy)
df_model['target'] = np.where(df_model['close_price'].shift(-1) > df_model['close_price'], 1, 0)

# Step 3: Select features and target
features = ['RSI', 'MA20', 'MA50']
X = df_model[features]
y = df_model['target']

print(f"‚úÖ Data prepared for {selected_stock}")
print(f"Features: {X.shape}")
print(f"Target: {y.shape}")

import xgboost as xgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

# Step 1: Split the data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Step 2: Initialize the XGBoost Classifier
model = xgb.XGBClassifier(use_label_encoder=False, eval_metric='logloss')

# Step 3: Train the model
model.fit(X_train, y_train)

# Step 4: Make predictions
y_pred = model.predict(X_test)

# Step 5: Evaluate accuracy
accuracy = accuracy_score(y_test, y_pred)
print(f"‚úÖ Model trained successfully. Accuracy: {accuracy:.2f}")

import requests

# Your Telegram bot token and chat ID
bot_token = '7719067949:AAGDZt5QUJHrfOGJt4frEea0VN08-V00gKA'
chat_id = '1111276484'


def send_telegram_message(message):
    url = f'https://api.telegram.org/bot{bot_token}/sendMessage'
    payload = {'chat_id': chat_id, 'text': message}
    response = requests.post(url, data=payload)
    if response.status_code == 200:
        print("‚úÖ Telegram message sent successfully.")
    else:
        print(f"‚ùå Failed to send message. Error: {response.text}")

# Send test message
send_telegram_message('üö® Test alert from your Trade Recommendation System!')

import time

# Example function to simulate checking a trade signal
def check_trade_signal():
    # In actual project: Add your model prediction or indicator logic here
    # Simulate a random buy signal for now
    return 'Buy Signal for TSLA'

# Real-time monitoring loop
while True:
    signal = check_trade_signal()
    send_telegram_message(f'üö® Trade Alert: {signal}')

    print('‚úÖ Signal sent. Waiting for next check...')

    # Check every 5 minutes (300 seconds)
    time.sleep(300)
try:
    while True:
        signal = check_trade_signal()
        send_telegram_message(f'üö® Trade Alert: {signal}')

        print('‚úÖ Signal sent. Waiting for next check...')
        time.sleep(300)
except KeyboardInterrupt:
    print('\n‚èπÔ∏è Monitoring stopped by user.')

import pandas as pd
import sqlite3

def check_trade_signals():
    import sqlite3

    # Connect to SQLite database
    conn = sqlite3.connect('trade_recommendation.db')
    cursor = conn.cursor()

    # Step 1: Get the most recent datetime per ticker efficiently
    query = """
    SELECT i.ticker, i.rsi
    FROM indicators i
    INNER JOIN (
        SELECT ticker, MAX(datetime) as max_datetime
        FROM indicators
        GROUP BY ticker
    ) latest
    ON i.ticker = latest.ticker AND i.datetime = latest.max_datetime
    """

    cursor.execute(query)
    results = cursor.fetchall()
    conn.close()

    signals = []

    for ticker, rsi_value in results:
        if rsi_value < 30:
            signals.append(f'üîî Buy Signal for {ticker} (RSI = {rsi_value:.2f})')
        elif rsi_value > 70:
            signals.append(f'üö® Sell Signal for {ticker} (RSI = {rsi_value:.2f})')

    return signals

import time

try:
    while True:
        signals = check_trade_signals()

        if signals:  # If there are signals
            for signal in signals:
                send_telegram_message(signal)
                print(f'‚úÖ Alert sent: {signal}')
        else:
            print('‚ÑπÔ∏è No signal detected. Waiting for next check...')

        # Wait for 5 minutes before next check
        time.sleep(300)

except KeyboardInterrupt:
    print('\n‚èπÔ∏è Monitoring stopped by user.')

import sqlite3

# Connect to your database
conn = sqlite3.connect('trade_recommendation.db')
cursor = conn.cursor()

# Create the indicators table
cursor.execute('''
    CREATE TABLE IF NOT EXISTS indicators (
        ticker TEXT,
        datetime TEXT,
        rsi REAL,
        ma20 REAL,
        ma50 REAL
    )
''')

conn.commit()
conn.close()

print('‚úÖ Table "indicators" created successfully.')

!pip install pandas_ta==0.3.14b

latest_data['rsi'] = ta.momentum.RSIIndicator(close=latest_data['Close'].squeeze(), window=14).rsi()

# Calculate indicators
latest_data['rsi'] = ta.momentum.RSIIndicator(close=latest_data['Close'].squeeze(), window=14).rsi()
latest_data['ma20'] = latest_data['Close'].rolling(window=20).mean()
latest_data['ma50'] = latest_data['Close'].rolling(window=50).mean()

# Prepare the most recent row to insert
latest_row = latest_data.iloc[-1]

# Extract single float values from each column
rsi_value = latest_row['rsi'].item()
ma20_value = latest_row['ma20'].item()
ma50_value = latest_row['ma50'].item()


# Insert into the database
conn = sqlite3.connect('trade_recommendation.db')
cursor = conn.cursor()

cursor.execute('''
    INSERT INTO indicators (ticker, datetime, rsi, ma20, ma50)
    VALUES (?, ?, ?, ?, ?)
''', (ticker, latest_row.name.strftime('%Y-%m-%d %H:%M:%S'), rsi_value, ma20_value, ma50_value))

conn.commit()
conn.close()

print(f"‚úÖ Updated indicators for {ticker} at {latest_row.name}")

from ta.momentum import RSIIndicator
from ta.trend import SMAIndicator
import yfinance as yf
import sqlite3

def update_indicators(ticker):
    data = yf.download(ticker, period='60d', interval='1h')

    # Extract the closing prices correctly
    close_prices = data['Close']

    # Calculate indicators using 'ta' library
    rsi_series = RSIIndicator(close=close_prices, window=14).rsi()
    ma20_series = SMAIndicator(close=close_prices, window=20).sma_indicator()
    ma50_series = SMAIndicator(close=close_prices, window=50).sma_indicator()

    # Add indicators to the DataFrame
    data['rsi'] = rsi_series
    data['ma20'] = ma20_series
    data['ma50'] = ma50_series

    # Extract the latest row's values
    latest_row = data.iloc[-1]
    rsi_value = float(latest_row['rsi'])
    ma20_value = float(latest_row['ma20'])
    ma50_value = float(latest_row['ma50'])
    latest_datetime = latest_row.name

    # Connect to SQLite database
    conn = sqlite3.connect('trade_recommendation.db')
    cursor = conn.cursor()

    # Insert the latest indicators into the database
    cursor.execute('''
        INSERT INTO indicators (ticker, datetime, rsi, ma20, ma50)
        VALUES (?, ?, ?, ?, ?)
    ''', (ticker, latest_datetime, rsi_value, ma20_value, ma50_value))

    conn.commit()
    conn.close()

    print(f'‚úÖ Updated indicators for {ticker} at {latest_datetime}')

from ta.momentum import RSIIndicator
from ta.trend import SMAIndicator

def update_indicators(ticker):
    data = yf.download(ticker, period='60d', interval='1h')

    # Calculate indicators using 'ta' library
    data['rsi'] = RSIIndicator(close=data['Close'], window=14).rsi()
    data['ma20'] = SMAIndicator(close=data['Close'], window=20).sma_indicator()
    data['ma50'] = SMAIndicator(close=data['Close'], window=50).sma_indicator()

    latest_row = data.iloc[-1]
    rsi_value = float(latest_row['rsi'].item())    # Force it to be a pure float
    ma20_value = float(latest_row['ma20'].item())  # Force it to be a pure float
    ma50_value = float(latest_row['ma50'].item())  # Force it to be a pure float
    latest_datetime = latest_row.name

    conn = sqlite3.connect('trade_recommendation.db')
    cursor = conn.cursor()

    cursor.execute('''
        INSERT INTO indicators (ticker, datetime, rsi, ma20, ma50)
        VALUES (?, ?, ?, ?, ?)
    ''', (ticker, latest_datetime, rsi_value, ma20_value, ma50_value))

    conn.commit()
    conn.close()

    print(f'‚úÖ Updated indicators for {ticker} at {latest_datetime}')

update_indicators('TSLA')

from ta.momentum import RSIIndicator
from ta.trend import SMAIndicator

def update_indicators(ticker):
    data = yf.download(ticker, period='60d', interval='1h')
    print(f"Downloaded data for {ticker}:")
    print(data.tail())  # Check if data is fetched correctly

    if data.empty:
        print("‚ùå No data fetched.")
        return

    try:
        # Calculate indicators using 'ta' library
        rsi_series = RSIIndicator(close=data['Close'], window=14).rsi()
        ma20_series = SMAIndicator(close=data['Close'], window=20).sma_indicator()
        ma50_series = SMAIndicator(close=data['Close'], window=50).sma_indicator()

        print("\n‚úÖ Calculated indicators shapes:")
        print('RSI:', rsi_series.shape)
        print('MA20:', ma20_series.shape)
        print('MA50:', ma50_series.shape)

        print("\n‚úÖ Latest indicator values:")
        print('RSI:', rsi_series.iloc[-1])
        print('MA20:', ma20_series.iloc[-1])
        print('MA50:', ma50_series.iloc[-1])

    except Exception as e:
        print("‚ùå Error during indicator calculation:", e)

from ta.momentum import RSIIndicator
from ta.trend import SMAIndicator
import yfinance as yf

def update_indicators(ticker):
    print(f"\n‚û°Ô∏è Starting update for {ticker}...")  # ‚úÖ Basic confirmation

    data = yf.download(ticker, period='60d', interval='1h')
    print(f"‚úÖ Data fetched. Shape: {data.shape}")  # Check if any rows exist

    if data.empty:
        print("‚ùå No data fetched. Try another ticker or check connection.")
        return

    try:
        rsi_series = RSIIndicator(close=data['Close'], window=14).rsi()
        ma20_series = SMAIndicator(close=data['Close'], window=20).sma_indicator()
        ma50_series = SMAIndicator(close=data['Close'], window=50).sma_indicator()

        print("\n‚úÖ Indicators calculated successfully.")
        print(f"RSI latest: {rsi_series.iloc[-1]}")
        print(f"MA20 latest: {ma20_series.iloc[-1]}")
        print(f"MA50 latest: {ma50_series.iloc[-1]}")

    except Exception as e:
        print(f"‚ùå Error calculating indicators: {e}")

# Call function directly to test
update_indicators('TSLA')

from ta.momentum import RSIIndicator
from ta.trend import SMAIndicator
import yfinance as yf

def update_indicators(ticker):
    print(f"\n‚û°Ô∏è Starting update for {ticker}...")

    data = yf.download(ticker, period='60d', interval='1h')
    print(f"‚úÖ Data fetched. Shape: {data.shape}")

    if data.empty:
        print("‚ùå No data fetched. Try another ticker or check connection.")
        return

    try:
        # Make sure we are passing a 1D Series
        close_series = data['Close'].squeeze()

        rsi_series = RSIIndicator(close=close_series, window=14).rsi()
        ma20_series = SMAIndicator(close=close_series, window=20).sma_indicator()
        ma50_series = SMAIndicator(close=close_series, window=50).sma_indicator()

        print("\n‚úÖ Indicators calculated successfully.")
        print(f"RSI latest: {rsi_series.iloc[-1]}")
        print(f"MA20 latest: {ma20_series.iloc[-1]}")
        print(f"MA50 latest: {ma50_series.iloc[-1]}")

    except Exception as e:
        print(f"‚ùå Error calculating indicators: {e}")

# Run to test
update_indicators('TSLA')

def update_indicators(ticker):
    print(f"‚û°Ô∏è Starting update for {ticker}...")
    data = yf.download(ticker, period='60d', interval='1h')
    print(f"‚úÖ Data fetched. Shape: {data.shape}")

    # Flatten multi-level columns
    data.columns = data.columns.get_level_values(0)

    try:
        # Calculate indicators using 'ta' library
        data['rsi'] = RSIIndicator(close=data['Close'], window=14).rsi()
        data['ma20'] = SMAIndicator(close=data['Close'], window=20).sma_indicator()
        data['ma50'] = SMAIndicator(close=data['Close'], window=50).sma_indicator()

        latest_row = data.iloc[-1]
        rsi_value = float(latest_row['rsi'])
        ma20_value = float(latest_row['ma20'])
        ma50_value = float(latest_row['ma50'])
        latest_datetime = str(latest_row.name)

        print(f"‚úÖ Indicators calculated successfully.")
        print(f"RSI latest: {rsi_value}")
        print(f"MA20 latest: {ma20_value}")
        print(f"MA50 latest: {ma50_value}")

        # Decision logic (more active)
        if rsi_value < 40:
            signal = 'üü¢ BUY'
        elif rsi_value > 60:
            signal = 'üî¥ SELL'
        else:
            signal = 'üü° HOLD'

        # Database update
        conn = sqlite3.connect('trade_recommendation.db')
        cursor = conn.cursor()

        cursor.execute('''
            INSERT INTO indicators (ticker, datetime, rsi, ma20, ma50)
            VALUES (?, ?, ?, ?, ?)
        ''', (ticker, latest_datetime, rsi_value, ma20_value, ma50_value))

        conn.commit()
        conn.close()
        print(f"‚úÖ Indicators for {ticker} at {latest_datetime} stored in DB.")

        # Prepare Telegram message with signal
        message = (f'üìä {ticker} Update:\n'
                   f'RSI: {rsi_value:.2f}\n'
                   f'MA20: {ma20_value:.2f}\n'
                   f'MA50: {ma50_value:.2f}\n'
                   f'Signal: {signal}\n'
                   f'Time: {latest_datetime}')

        # Send Telegram alert
        send_telegram_message(message)

    except Exception as e:
        print(f"‚ùå Error: {e}")

update_indicators('TSLA')

latest_row = data.iloc[-1]
print(latest_row)

import time

tickers = ['TSLA', 'AAPL', 'EURUSD=X', 'GC=F', 'CL=F']  # Add any tickers you want

try:
    while True:
        for ticker in tickers:
            update_indicators(ticker)
            print(f'‚úÖ {ticker} updated. Waiting for next ticker...\n')
        print('‚è≥ Waiting 60 seconds before the next update cycle...\n')
        time.sleep(60)  # Wait 60 seconds before the next cycle

except KeyboardInterrupt:
    print('üõë Stopped updating.')

import os
print(os.path.abspath('trade_recommendation.db'))

from google.colab import files
files.download('/content/trade_recommendation.db')

